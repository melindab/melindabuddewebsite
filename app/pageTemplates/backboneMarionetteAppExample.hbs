<div class="container">
    <h2>Building an App with Backbone, Marionette, and Browserify</h2>
    <p>
        Backbone may not be the hottest JavaScript framework these days, but it still is used in a lot of projects. As a JavaScript developer, there is a likelihood you will encounter it at some point. This example demonstrates most of the Backbone features you will need to know when working on a professional Backbone website. It uses two libraries that are commonly used with Backbone applications, Marionette and Browserify. You can find the complete project files at <a href="https://github.com/melindab/backbone-marionette-example"><strong>github.com/melindab/backbone-marionette-example</strong></a>.
    </p>
    <h3>Dependencies</h3>
    <p>
        The first step is to install the project's dependencies. In order to keep track of which libraries and versions are installed, create a file called package.json. This file makes it easy for reinstallations and for others to use your code. The package manager, NPM, will be used to install it. See <a href="managing-dependencies-with-npm.html"><strong>Managing Dependencies with NPM</strong></a> for more information.
    </p>
    <p>
        Create a folder to contain the application. In the folder, create the package.json file.
    <p>
    <p class="file-name">package.json</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            {<br>
            <span class="tab-1">"name": "backboneexample",</span><br>
            <span class="tab-1">"version": "1.0.0"</span><br>
            }<br>
        </code>
    </div>
    <p>
        Install dependencies and save them to the package.json file at the same time by entering these commands into your command line interface (CLI):
    </p>
    <div class="boxed mb-blue lighten-2">
        <code>
            npm install backbone --save<br>
            npm install backbone.marionette --save<br>
            npm install materialize-css --save<br>
            npm install handlebars --save<br>
            npm install hbsfy --save-dev<br>
            npm install -g browserify
        </code>
    </div>
    <p>
        Backbone, Marionette, Materialize, Handlebars, and hbsfy will be added to the package.json file and installed in a folder called node_modules. Note that Browserify is installed globally and will not show up in the package.json file.
    </p>
    <p>
        In case you are wondering what all these libraries will be doing for us, here's the lowdown: Backbone will be the project's primary framework, giving it structure through the use of models and views. Marionette is built upon Backbone, and will provide additional helper attributes, methods, and views. Browserify will enable JavaScript files to be exported and loaded as modules. It will also bundle all the JavaScript code into one file. Handlebars will provide the ability to create HTML-like templates, and hbsfy will precompile the templates so they can be used with Browserify. Finally, Materialize will provide some default styles and functionality.
    </p>
    <h3>Creating the HTML File</h3>
    <p>
        Once all the dependencies are installed, make a folder called <em>app</em> to store all of the application's files. This is not necessary, but will keep the files organized, especially if you decide to add a back-end in the future.
    </p>
    <p>In a text editor or IDE, create the following index.html file in the app folder:</p>
    <p class="file-name">index.html</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            &lt;!DOCTYPE html&gt;<br>
            &lt;html&gt;<br>
            <div class="tab-1">&lt;head&gt;</div>
            <div class="tab-2">&lt;title&gt;Example Backbone/Marionette App&lt;/title&gt;</div>
            <div class="tab-2">&lt;link type="text/css" rel="stylesheet" href="../node_modules/materialize-css/dist/css/materialize.min.css"  media="screen,projection"&gt;</div>
            <div class="tab-2">&lt;link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"&gt;</div>
            <div class="tab-2">&lt;meta charset="utf-8"&gt;</div>
            <div class="tab-2">&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</div>
            <div class="tab-1">&lt;/head&gt;</div>
            <div class="tab-1">&lt;body&gt;</div>
            <div class="tab-2">&lt;div id="app"&gt;&lt;/div&gt;</div>
            <div class="tab-2">&lt;script src="js/bundle.js"&gt;&lt;/script&gt;</div>
            <div class="tab-1">&lt;/body&gt;</div>
            &lt;/html&gt;
        </code>
    </div>
    <p>
        The three things you should note here are the materialize.min.css stylesheet, the #app div, and the script tag for the bundle.js file. The stylesheet is part of the Materialize framework. It will give the project its look, so you won't need to write any CSS. This application will also use Materialize to add a slide-out side navigation component. There is no script element for the Materialize JavaScript file that contains this functionality. That is because its code is included in the bundle.js file that will be created using Browserify. All of the JavaScript code will be contained in this file. That is the beauty of Browserify. You only need to create one script tag for all of the JavaScript code.
    </p>
    <p>
        Everything that the user will be able to see will be contained inside the #app div. This application will be a single-page app (SPA). It will appear to contain multiple pages, but will really be one single page that swaps out the content when a user navigates.
    </p>
    <h3>Starting the App</h3>
    <p>
        The first JavaScript file you will create is App.js. In the app folder, add a folder called js to hold this and all your JavaScript files.
    </p>
    <p class="file-name">App.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            <div class="comment">
                /* Requiring dependencies that are used in this component
                tells Browserify to add them to our bundle.
                Assign them to a variable to get access to the
                properties and methods within. */
            </div>
            var Backbone = require('backbone');<br>
            var Marionette = require('backbone.marionette');<br>
            <div class="comment">
                /* Require AppView.js so that the view can be instantiated and shown in the onStart method below. */
            </div>
            var AppView = require('./views/AppView');<br>
            <br>
            <div class="comment">
                /* Extend the built-in Marionette Application Object. */
            </div>
            var App = Marionette.Application.extend({<br>
            <div class="tab-2">
                <div class="comment">
                    /* The region property is a built-in Marionette 3 attribute
                    that inserts the app view in the specified element. Note
                    that this is called "region" (singular) in the Application
                    object, but is called "regions" (plural) in views. */
                </div>
                region: '#app',<br>
                <br>
                <div class="comment">
                    /* The onStart method is a built-in event callback that is part of Marionette's
                    lifecycle (the order in which Marionette triggers various built-in events).
                    Any code you add in this function is run when App.start() is called.
                    This will be called in another file called main.js. */
                </div>
                onStart: function() {<br>
            </div>
            <div class="tab-3">
                <div class="comment">
                    /* showView() is a built-in Marionette 3 method that shows a view. */
                </div>
                this.showView(new AppView());<br>
            </div>
            <div class="tab-2">
                }<br>
            </div>
            });<br>
            <br>
            <div class="comment">
                /* Export and initialize the App component. */
            </div>
            module.exports = new App();
        </code>
    </div>
    <p>
        The main purpose of the Application object is to declare that AppView.js is the view to show when the application is started. A view is an object that controls what a user will interact with or see. AppView.js will specify the html structure that will be inserted into the #app element in index.html, as well as any functionality associated with it.
    </p>
    <p>
        At the top of the file are require stements assigned to variables. These tell Browserify that the specified libraries and components are needed in order for the this file to work and to include them in the bundle. If the path is just the name of the file, Browserify assumes it is a library and looks in the node_modules folder. Note that ".js" can be left off the file name if the file is JavaScript. If it is an .html file or anything else, the extension will need to be specified.
    </p>
    <p>
        There are certain properties, methods, and events that are built into Backbone and Marionette, such as the region property and the showView method of the Application object. The values you set are used in specific ways by these frameworks. For instance, the element specified by the region property declares where the view will be inserted. You can also create your own custom properties and methods, as you will see later.
    </p>
    <p>
        The application is initialized and exported at the same time since only one instance is needed. Objects are exported so they can be used by other components. In this case, it will be used by the file that starts the application, main.js.
    </p>
    <p>
        Create the main.js file now. Require the App.js file you just created and assign it to a variable called App. Then, call the start method on App, which triggers the onStart event callback in App.js.
    </p>
    <p class="file-name">main.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var App = require('./App');<br>
            require('hammerjs');<br>
            require('materialize-css');<br>
            <br>
            App.start();
        </code>
    </div>
    <p>
        The Materialize and Hammer libraries are not assigned to variables because they are never used as variables. This is just a quick way to get these libraries included into our bundle for this tutorial. Since this file is the entry point to the app, they were added here. Note that despite having <em>css</em> in the name, <em>materialize-css</em> is a JavaScript file.
    </p>
    <h3>The Parent View</h3>
    <p>
        You now need to create the AppView.js file that was required in App.js. This will be the parent, or containing, view to all the other views. Add a views folder in the js folder to hold this and all view files.
    </p>
    <p class="file-name">AppView.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Marionette = require('backbone.marionette');<br>
            <div class="comment">/* This template will describe the DOM structure of the parent view. */</div>
            var appTemplate = require('../../templates/appTemplate.hbs');<br>
            <div class="comment">/* HeaderView and MainView will be child views. */</div>
            var HeaderView = require('./HeaderView');<br>
            var MainView = require('./MainView');<br>
            <br>
            <div class="comment">
                /* Marionette.View is built upon Backbone.View.
                It describe how data will be displayed. */
            </div>
            module.exports = Marionette.View.extend({
                <div class="tab-1">
                    <div class="comment">/* The el property is a built-in Backbone attribute that defines which element is the parent element of the view's html. If it is not defined, the parent element will be a div. */</div>
                    el: '#app',<br>
                    <br>
                    <div class="comment">/* The template property is a built-in Backbone attribute that allows a template function or file to be used to create the structure of the page. */</div>
                    template: appTemplate,<br>
                    <br>
                    <div class="comment">/* The regions property is a built-in Marionette property that declares which elements will hold the various sub-views on the page. */</div>
                    regions: {<br>
                </div>
                <div class="tab-2">
                    headerRegion: '#header-region',<br>
                    mainRegion: '#main-region'<br>
                </div>
                <div class="tab-1">
                    },<br>
                    <br>
                    <div class="comment">
                        /* The onRender method is a Marionette event callback that is called after the view has rendered. The parent should be rendered before rendering the child views, so showChildView is not called on the child views until onRender. In the region specified above as headerRegion, a new HeaderView instance will be rendered (and so on for the other two regions). Marionette automatically renders the views, so you don't need to call render like you do in Backbone unless you need to force a re-render. */
                    </div>
                    onRender: function() {<br>
                </div>
                <div class="tab-2">
                    this.showChildView('headerRegion', new HeaderView());<br>
                    this.showChildView('mainRegion', new MainView());<br>
                </div>
                <div class="tab-1">
                    }<br>
                </div>
            });
        </code>
    </div>
    <p>
        This file tells the app to use the template to produce the HTML structure for this view. Inside that structure will be elements called #header-region and #main-region. The sub-views, HeaderView and MainView, will be inserted in these two elements, respectively. The view then inserts, or shows, the sub-views. This all gets inserted into the #app region specified in App.js. If you are wondering why you need to define #app as the el, it is so that the header and main content sections are inserted directly into the #app element. If the el was not specified, it would nest the elements in another div before nesting it in #app.
    </p>
    <p>
        The appTemplate.hbs file is a Handlebars (.hbs) file and not HTML. Using a templating library like Handlebars allows you to work with separate HTML-like files so you don't have to deal with the long, messy strings of HTML associated with manipulating the DOM and template functions. Basically, you are creating DOM elements with JavaScript but it <em>feels</em> like you are just writing HTML.
    </p>
    <p>
        Create the appTemplate.hbs now. Add a folder called templates in the app folder to store this and other .hbs files.
    </p>
    <p class="file-name">appTemplate.hbs</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            &lt;header id="header-region"&gt;&lt;/header&gt;<br>
            &lt;main id="main-region"&gt;&lt;/main&gt;<br>
        </code>
    </div>
    <h3>The Child Views</h3>
    <p>
        HeaderView and MainView are called child views of AppView because they are contained by AppView. In the views folder, create HeaderView.js and MainView.js.
    </p>
    <p class="file-name">HeaderView.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Marionette = require('backbone.marionette');<br>
            var headerTemplate = require('../../templates/headerTemplate.hbs');<br>
            <br>
            module.exports = Marionette.View.extend({<br>
                <div class="tab-1">
                    el: '#header-region',<br>
                    <br>
                    template: headerTemplate,<br>
                    <br>
                    <div class="comment">
                        /* The ui hash is a built-in Marionette attribute that allows easy access to elements in the view using the getUI method. */
                    </div>
                    ui: {<br>
                </div>
                <div class="tab-2">
                    menuButton: '.button-collapse'<br>
                </div>
                <div class="tab-1">
                    },<br>
                    <br>
                    onRender: function() {<br>
                </div>
                <div class="tab-2">
                    <div class="comment">
                        /* The getUI method is built into Marionette. It gets the element specified as <em>menuButton</em> in the ui hash in the same way it could be accessed with jQuery using $('.button-collapse'). The sideNav function is part of Materialize. It will turn the element into a slide-out menu. */
                    </div>
                    this.getUI('menuButton').sideNav();<br>
                </div>
                <div class="tab-1">
                    }<br>
                </div>
            });
        </code>
    </div>
    <p class="file-name">MainView.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Marionette = require('backbone.marionette');<br>
            var mainTemplate = require('../../templates/mainTemplate.hbs');<br>
            <br>
            module.exports = Marionette.View.extend({<br>
                <div class="tab-1">
                    el: '#main-region',<br>
                    template: mainTemplate<br>
                </div>
            });
        </code>
    </div>
    <h3>Child View Templates</h3>
    <p>
        Next, add the templates for each of the child views to the templates folder. The main content file is very simple right now, but it will be built out later.
    </p>
    <p class="file-name">headerTemplate.hbs</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            &lt;nav&gt;<br>
                <div class="tab-1">&lt;div class="container center"&gt;</div>
                    <div class="tab-2">&lt;a href="#/page-1"&gt;Sample Backbone/Marionette App&lt;/a&gt;</div>
                    <div class="tab-2">&lt;a href="#" data-activates="nav-mobile" class="button-collapse show-on-large"&gt;</div>
                        <div class="tab-3">&lt;i class="material-icons"&gt;menu&lt;/i&gt;</div>
                    <div class="tab-2">&lt;/a&gt;</div>
                <div class="tab-1">&lt;/div&gt;</div>
            &lt;/nav&gt;<br>
            <br>
            &lt;ul id="nav-mobile" class="side-nav"&gt;<br>
                <div class="tab-1">&lt;li&gt;&lt;a href="#/page-1"&gt;Page 1&lt;/a&gt;&lt;/li&gt;</div>
                <div class="tab-1">&lt;li&gt;&lt;a href="#/page-2"&gt;Page 2&lt;/a&gt;&lt;/li&gt;</div>
                <div class="tab-1">&lt;li&gt;&lt;a href="#/page-3"&gt;Page 3&lt;/a&gt;&lt;/li&gt;</div>
            &lt;/ul&gt;
        </code>
    </div>
    <p class="file-name">mainTemplate.hbs</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            &lt;div class="container"&gt;
                <div class="tab-1">
                    This is the main content.
                </div>
            &lt;/div&gt;
        </code>
    </div>
    <h3>Browserify</h3>
    <p>
        It is time to see how the app looks so far. On the command line, type in the command below. (The path assumes you are running the command after cding to the top-most level of your project directory. Adjust as necessary for your situation.)
    </p>
    <div class="boxed mb-blue lighten-2">
        <code>
            browserify -t hbsfy app/js/main.js -o app/js/bundle.js
        </code>
    </div>
    <p>
        This command precompiles the Handlebars files to JavaScript. Then Browserify bundles all the JavaScript files starting at main.js and saves them as bundle.js. This is the file we referenced in index.html. Now if you open up the index.html file in a browser, you will see a very barebones app with a menu that can be opened and closed!
    </p>
    <h3>Models and Collections</h3>
    <p>
        Hard-coding all the items in the side navigation is not the best way to go. It would be better to have a collection of routes to use as a single source of truth. A collection is a container for an array of models. Models are objects that hold data to be used in views. When a collection is created from an array of objects, the objects are automatically converted to models. The routes collection will use a special kind of view called a CollectionView that will automatically iterate through the collection and add each item to the view.
    </p>
    <p>First, update the headerTemplate.hbs file by removing the list items from the unordered list.</p>
    <p class="file-name">headerTemplate.hbs</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            &lt;nav&gt;<br>
                <div class="tab-1">&lt;div class="container center"&gt;</div>
                    <div class="tab-2">&lt;a href="#/page-1"&gt;Sample Backbone/Marionette App&lt;/a&gt;</div>
                    <div class="tab-2">&lt;a href="#" data-activates="nav-mobile" class="button-collapse show-on-large"&gt;</div>
                        <div class="tab-3">&lt;i class="material-icons"&gt;menu&lt;/i&gt;</div>
                    <div class="tab-2">&lt;/a&gt;</div>
                <div class="tab-1">&lt;/div&gt;</div>
            &lt;/nav&gt;<br>
            <br>
            <strong>&lt;ul id="nav-mobile" class="side-nav"&gt;&lt;/ul&gt;</strong>
        </code>
    </div>
    <p>
        Now, create a template for each link. Don't worry that no list element exists in the template. We are going to take care of that in the view.
    </p>
    <p class="file-name">navItemTemplate.hbs</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            &lt;a id="&#123;&#123; href &#125;&#125;" href="#/&#123;&#123; href &#125;&#125;"&gt;
                <div class="tab-1">&#123;&#123; text &#125;&#125;</div>
            &lt;/a&gt;
        </code>
    </div>
    <p>
        The code with the curly braces is called a Handlebars expression. It will evaluate to the value of the code between the braces. <em>href</em> and <em>text</em> correspond to the attributes of the same name on a model in the collection.
    </p>
    <p>
        Next, create the view that will be used for each item.
    </p>
    <p class="file-name">NavItemView.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Marionette = require('backbone.marionette');<br>
            var navItemTemplate = require('../../templates/navItemTemplate.hbs');<br>
            <br>
            module.exports = Marionette.View.extend({
                <div class="tab-1">
                    <div class="comment">
                        /* The tagName property is a built-in Backbone attribute that can be used to declare what kind of element should be used as the containing element. Since this is a child view of NavItemsView, the containing li element will be inserted inside the el defined in NavItemsView. */
                    </div>
                </div>
                <div class="tab-1">tagName: 'li',</div>
                <br>
                <div class="tab-1">
                    <div class="comment">
                        /* The className property is a built-in Backbone attribute that can be used to define the classes to be set on the containing element. */
                    </div>
                </div>
                <div class="tab-1">className: 'side-links',</div>
                <br>
                <div class="tab-1">template: navItemTemplate</div>
            });
        </code>
    </div>
    <p>
        Then, create the parent view, the CollectionView.
    </p>
    <p class="file-name">NavItemsView.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var $ = require('jquery');<br>
            var Backbone = require('backbone');<br>
            var Marionette = require('backbone.marionette');<br>
            var NavItemView = require('./NavItemView');<br>
            <br>
            <div class="comment">
                /* CollectionView is a Marionette object that automatically
                iterates through the array and adds each item to the view. */
            </div>
            module.exports = Marionette.CollectionView.extend({
                <div class="tab-1">
                    <div class="comment">
                        /* All child views will be rendered
                        within the element specified as el. */
                    </div>
                </div>
                <div class="tab-1">el: '#nav-mobile',</div>
                <br>
                <div class="tab-1">
                    <div class="comment">
                        /* The childView property is a built-in Marionette attribute. It specifies the view that will be used for all child elements. */
                    </div>
                </div>
                <div class="tab-1">childView: NavItemView,</div>
                <br>
                <div class="tab-1">
                    <div class="comment">
                        /* The collection property is a built-in Marionette attribute
                        that declares the collection to be used. Note that
                        Backbone.Collection is a Backbone object, not Marionette.
                        A collection is an object that contains an array of models.
                        The array of items is being passed into the collection
                        directly here, but it could also be fetched via HTTP request.
                        Every item will automatically be converted to a Backbone model.
                        A model contains all the data for a view. It has a lot of
                        built-in properties and methods that facilitate the getting
                        and setting of data. */
                    </div>
                </div>
                <div class="tab-1">collection: new Backbone.Collection([</div>
                    <div class="tab-2">{</div>
                        <div class="tab-3">"href": "page-1",</div>
                        <div class="tab-3">"text": "Page 1"</div>
                    <div class="tab-2">},</div>
                    <div class="tab-2">{</div>
                        <div class="tab-3">"href": "page-2",</div>
                        <div class="tab-3">"text": "Page 2"</div>
                    <div class="tab-2">},</div>
                    <div class="tab-2">{</div>
                        <div class="tab-3">"href": "page-3",</div>
                        <div class="tab-3">"text": "Page 3"</div>
                    <div class="tab-2">}</div>
                <div class="tab-1">])</div>
            });
        </code>
    </div>
    <p>
        Update the HeaderView.js file so that unordered list in the header template is a region. Show NavItemsView.js in that region.
    </p>
    <p class="file-name">HeaderView.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Marionette = require('backbone.marionette');<br>
            var headerTemplate = require('../../templates/headerTemplate.hbs');<br>
            <strong>var NavItemsView = require('./NavItemsView');</strong><br>
            <br>
            module.exports = Marionette.View.extend({<br>
                <div class="tab-1">
                    el: '#header-region',<br>
                    <br>
                    template: headerTemplate,<br>
                    <br>
                    <strong>regions: {</strong>
                </div>
                <div class="tab-2">
                    <strong>navItemsRegion: '#nav-mobile'</strong>
                </div>
                <div class="tab-1">
                    <strong>},</strong><br>
                    <br>
                    ui: {<br>
                </div>
                <div class="tab-2">
                    menuButton: '.button-collapse'<br>
                </div>
                <div class="tab-1">
                    },<br>
                    <br>
                    onRender: function() {<br>
                </div>
                <div class="tab-2">
                    <strong>this.showChildView('navItemsRegion', new NavItemsView());</strong><br>
                    this.getUI('menuButton').sideNav();<br>
                </div>
                <div class="tab-1">
                    }<br>
                </div>
            });
        </code>
    </div>
    <p>
        Type the Browserify command in the command line again to create an updated bundle.js file and refresh index.html. Everything should look the same as before.
    <p>
    <h3>The Content Model</h3>
    <p>
        There is one problem with the side navigation items &mdash; the links in the menu don't take us anywhere. In order to navigate to a new page, the app will use a router. It will need some content to show on each page. In a real-world application, content is often stored in a database and must be retrieved from a server. To simulate this, you will create a mock service using <a href="https://www.mockable.io/"><strong>mockable.io</strong></a> and make an HTTP request using built-in Backbone methods to fetch the data.
    </p>
    <p>
        Make a free account with Mockable if you don't have one already. Once you have created the account, you will be presented with a screen with a tab that says <em>My Domains</em>. There will be a url below this that says something like demo#######.mockable.io. Click this link, then click the button that says +REST Mock. You will now see a screen called REST MOCK. In the Path field, type <em>content</em>. The Verb field should already have the GET option selected and the Response status field should be set to 200 - OK. Change the Response body field from the placeholder Hello World message object to:
    </p>
    <div class="boxed mb-blue lighten-2">
        <code>
            {
                <div class="tab-1">"content": {</div>
                    <div class="tab-2">"page-1": "&lt;h2&gt;Page 1 Heading&lt;/h2&gt;&lt;p&gt;This is page 1 content. This is page 1 content. This is page 1 content. This is page 1 content. This is page 1 content. This is page 1 content. This is page 1 content. This is page 1 content. This is page 1 content. This is page 1 content.&lt;/p&gt;",</div>
                    <div class="tab-2">"page-2": "&lt;h2&gt;Page 2 Heading&lt;/h2&gt;&lt;p&gt;This is page 2 content. This is page 2 content. This is page 2 content. This is page 2 content. This is page 2 content. This is page 2 content. This is page 2 content. This is page 2 content. This is page 2 content. This is page 2 content.&lt;/p&gt;",</div>
                    <div class="tab-2">"page-3": "&lt;h2&gt;Page 3 Heading&lt;/h2&gt;&lt;p&gt;This is page 3 content. This is page 3 content. This is page 3 content. This is page 3 content. This is page 3 content. This is page 3 content. This is page 3 content. This is page 3 content. This is page 3 content. This is page 3 content.&lt;/p&gt;"</div>
                <div class="tab-1">}</div>
            }
        </code>
    </div>
    </p>
        Click the Save button at the bottom of the screen when you are done. Then click the Stopped button. This will change to Started. Now, update the mainTemplate.hbs file.
    </p>
    <p class="file-name">mainTemplate.hbs</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            <div class="comment">
            &lt;!--
                The "activeContent" expression corresponds to the activeContent attribute on the model. Normally the expression has two curly braces on either side and is automatically escaped. Handlebars expressions with three curly braces prevent the value from being escaped, which is what is used here since the content will contain html.
            --&gt;
            </div>
            &lt;div class="container"&gt;
                <div class="tab-1"><strong>&#123;&#123;&#123; activeContent &#125;&#125;&#125;</strong></div>
            &lt;/div&gt;
        </code>
    </div>
    <p>
        A model will be needed to contains all of the content data. Add a folder called models in the js folder, then create the MainContent.js file.
    </p>
    <p class="file-name">MainContent.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Backbone = require( 'backbone' );<br>
            <br>
            <div class="comment">
                /* Model is a Backbone object, not Marionette. */
            </div>
            module.exports = Backbone.Model.extend({<br>
                <div class="tab-1">
                    <div class="comment">
                        /* The url property is a built-in Backbone attribute that
                        indicates the location of the data (in this case,
                        the mockable url). Make sure to replace this url with
                        the url from your account. */
                    </div>
                </div>
                <div class="tab-1">url: 'http://demo#######.mockable.io/content'<strong>,</strong></div>
                <br>
                <div class="tab-1">
                    <div class="comment">
                        /* The defaults property is a built-in Backbone attribute. Setting defaults sets default attributes on the model in a property aptly named "attributes." The key/value pairs in the JSON fetched from the url above will also be added as attributes to the model if the call is successful. If an attribute in the JSON has the same name as a default, it will overwrite it. */
                    </div>
                </div>
                <div class="tab-1">defaults: {</div>
                    <div class="tab-2">
                        <div class="comment">
                            /* Because initial navigation occurs before the content is fetched, the string indicating the route is stored as the value of activePage. Then, once the content is fetched, activeContent can be determined during rendering. */
                        </div>
                    </div>
                    <div class="tab-2">activePage: null,</div><br>
                    <div class="tab-2">
                        <div class="comment">
                        /* activeContent is the content that mainTemplate
                        will display in place of &#123;&#123;&#123; activeContent &#125;&#125;&#125;. */
                        </div>
                    </div>
                    <div class="tab-2">activeContent: function() {</div>
                        <div class="tab-3">var calledFailed = this.activePage === 'error';</div>
                        <div class="tab-3">var pageNotFound = this.activePage &amp;&amp; this.content &amp;&amp; !this.content[this.activePage];</div>
                        <div class="tab-3">var contentExists = this.activePage &amp;&amp; this.content &amp;&amp; this.content[this.activePage];</div>
                        <br>
                        <div class="tab-3">if (contentExists) {</div>
                            <div class="tab-4">return this.content[this.activePage];</div>
                        <div class="tab-3">}</div>
                        <br>
                        <div class="tab-3">if (calledFailed || pageNotFound) {</div>
                            <div class="tab-4">return this.error;</div>
                        <div class="tab-3">}</div>
                    <div class="tab-2">},</div><br>
                    <div class="tab-2">error: '&lt;h2&gt;Error&lt;/h2&gt;&lt;div&gt;This is error content.&lt;/div&gt;'</div>
                <div class="tab-1">},</div>
                <br>
                <div class="tab-1">setActiveContent: function(page) {</div>
                    <div class="tab-2">
                        <div class="comment">
                            /* activePage is a custom method that is set whenever there is navigation. This is called in MainView. */
                        </div>
                    </div>
                    <div class="tab-2">this.set('activePage', page);</div>
                <div class="tab-1">}</div>
            });<br>
        </code>
    </div>
    <p>
        This model does several things. It defines the default data, the location of the data to be fetched, and a method to set the active content. There is also a built-in fetch method on Backbone models that can be called to get the data. If the call is successful, it will automatically populate the model's attributes property with the response data. This method will be called in MainView.js.
    </p>
    <p>
        Update MainView.js by adding a variable that requires the MainContent.js file. Then create a new instance of it and assign it as the value of the model property. When the view initializes, call the model's fetch method to get the content data.
    </p>
    <p class="file-name">MainView.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Marionette = require('backbone.marionette');<br>
            var mainTemplate = require('../../templates/mainTemplate.hbs');<br>
            <strong>var MainContent = require('../models/MainContent');</strong><br>
            <br>
            module.exports = Marionette.View.extend({<br>
                <div class="tab-1">el: '#main-region',</div>
                <br>
                <div class="tab-1">template: mainTemplate<strong>,</strong></div>
                <br>
                <div class="tab-1">
                    <div class="comment">
                        /* The model property is a built-in Backbone attribute that defines the model that contains the view's data. */
                    </div>
                </div>
                <div class="tab-1"><strong>model: new MainContent(),</strong></div>
                <br>
                <div class="tab-1">
                    <div class="comment">
                        /* The built-in Backbone initialize method is
                        called when the instance is created. */
                    </div>
                </div>
                <div class="tab-1"><strong>initialize: function() {</strong></div>
                    <div class="tab-2"><strong>var that = this;</strong></div>
                    <br>
                    <div class="tab-2">
                        <div class="comment">
                            /* The fetch method is built into Backbone models.
                            A successful call will populate the model.
                            The Backbone fetch method returns a promise
                            so it can be chained with done(), fail(), etc. */
                        </div>
                    </div>
                    <div class="tab-2"><strong>this.model.fetch()</strong></div>
                        <div class="tab-3"><strong>.fail(function() {</strong></div>
                            <div class="tab-4"><strong>that.model.setActiveContent('error');</strong></div>
                        <div class="tab-3"><strong>})</strong></div>
                        <div class="tab-3"><strong>.always(function() {</strong></div>
                            <div class="tab-4"><strong>that.render();</strong></div>
                        <div class="tab-3"><strong>});</strong></div>
                <div class="tab-1"><strong>}</strong></div>
            });
        </code>
    </div>
    <h3>The Router and Controller</h3>
    <p>
        Next, create a router that will alert the rest of the application when a user has navigated to a particular page. The router will use Backbone.Radio to communicate with all components of the application. It will trigger an event on a Backbone.Radio channel. MainView will listen on the channel and will show the appropriate content when it hears the event.
    </p>
    <p>
        Create a folder called routers in the js folder to store the router and its controller. The router will specify which methods in the controller are called when the user navigates to a page. The controller will define the methods that trigger navigation events.
    </p>
    <p class="file-name">AppRouter.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Marionette = require('backbone.marionette');<br>
            var AppController = require('./AppController');<br>
            <br>
            <div class="comment">
                /* AppRouter is a Marionette object that extends Backbone.Router.
                It is used in this application to trigger the code that shows
                the appropriate content when the user navigates to a page. */
            </div>
            module.exports = Marionette.AppRouter.extend({<br>
                <div class="tab-1">
                    <div class="comment">
                        /* The controller property is a built-in Marionette attribute that
                        specifies the methods used by appRoutes below. */
                    </div>
                </div>
                <div class="tab-1">controller: new AppController(),</div>
                <br>
                <div class="tab-1">
                    <div class="comment">
                        /* The key for each key/value pair in appRoutes is the route fragment, and the value is the method that will be called in the controller when that route is matched. The colon preceeding ':page' means that it is not a literal route fragment. It is a parameter called "page" that will match any URL component between slashes. If the user navigates anywhere other than the base url, it will call the showPage method. */
                    </div>
                </div>
                <div class="tab-1">appRoutes: {</div>
                    <div class="tab-2">'': 'showDefault',</div>
                    <div class="tab-2">':page': 'showPage'</div>
                <div class="tab-1">}</div>
            });
        </code>
    </div>
    <p class="file-name">AppController.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Marionette = require('backbone.marionette');<br>
            var Radio = require('backbone.radio');<br>
            <br>
            <div class="comment">
                /* The methods the router uses in AppRoutes are contained
                in the controller. The controller can just be a regular
                object, but using Marionette.Object provides access to
                all of its built-in utilities. */
            </div>
            module.exports = Marionette.Object.extend({<br>
                <div class="tab-1">
                    <div class="comment">
                        /* channel is a custom property we are setting
                        to easily access the Radio channel. */
                    </div>
                </div>
                <div class="tab-1">channel: Radio.channel('app'),</div>
                <br>
                <div class="tab-1">
                    <div class="comment">
                        /* If a user navigates to the base url of the site,
                        page 1 will be shown. */
                    </div>
                </div>
                <div class="tab-1">showDefault: function() {</div>
                    <div class="tab-2">
                        <div class="comment">
                            /* Trigger a navigate event and pass 'page-1' as an argument. */
                        </div>
                    </div>
                    <div class="tab-2">this.channel.trigger('navigate', 'page-1');</div>
                <div class="tab-1">},</div>
                <br>
                <div class="tab-1">
                    <div class="comment">
                        /* The router passes the route to showPage, which then triggers the navigation event that will trigger that route's content to be shown. */
                    </div>
                </div>
                <div class="tab-1">showPage: function(page) {</div>
                    <div class="tab-2">
                        <div class="comment">
                            /* Trigger a navigate event and pass the route as an argument. */
                        </div>
                    </div>
                    <div class="tab-2">this.channel.trigger('navigate', page);</div>
                <div class="tab-1">}</div>
            });
        </code>
    </div>
    <p>
        In AppRouter.js, we use the same method for every page except the homepage, however we could create a separate method for every page. In the example below, if a user clicks the link that navigtes to <em>#/page-1</em>, the showPageOne method in the controller would be called.
    </p>
    <div class="boxed mb-blue lighten-2">
        <code>
            appRoutes: {
                <div class="tab-1">'': 'showDefault',</div>
                <div class="tab-1">'page-1': 'showPageOne',</div>
                <div class="tab-1">'page-2': 'showPageTwo',</div>
                <div class="tab-1">'page-3': 'showPageThree'</div>
            }
        </code>
    </div>
    <p>
        Update the App.js file by requiring and creating an instance of the router. Call Backbone.history.start() to make the router start listening for and acting on a window's hash changes. The router will do nothing until this is called.
    </p>
    <p class="file-name">App.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Backbone = require('backbone');<br>
            var Marionette = require('backbone.marionette');<br>
            var AppView = require('./views/AppView');<br>
            <strong>var AppRouter = require('./routers/AppRouter');</strong><br>
            <br>
            var App = Marionette.Application.extend({<br>
            <div class="tab-2">
                region: '#app',<br>
                <br>
                <div class="comment">
                    /* Define the router used to trigger content change when a user navigates. */
                </div>
                <strong>router: new AppRouter(),</strong><br>
                <br>
                onStart: function() {<br>
            </div>
            <div class="tab-3">
                this.showView(new AppView());<br>
                <div class="comment">
                    /* Tell the router to start listening for navigation. */
                </div>
                <strong>Backbone.history.start();</strong>
            </div>
            <div class="tab-2">
                }<br>
            </div>
            });<br>
            <br>
            module.exports = new App();
        </code>
    </div>
    <p>
        Lastly, define the radio channel that the router will use to communicate with the application and set a listener on it to change the content when a user navigates. Update MainView.js by requiring Backbone.Radio, defining the radio channel and naming it <em>app</em>, and setting the listener.
    </p>
    <p class="file-name">MainView.js</p>
    <div class="boxed mb-blue lighten-2">
        <code>
            var Marionette = require('backbone.marionette');<br>
            var mainTemplate = require('../../templates/mainTemplate.hbs');<br>
            var MainContent = require('../models/MainContent');<br>
            <strong>var Radio = require('backbone.radio');</strong><br>
            <br>
            module.exports = Marionette.View.extend({<br>
                <div class="tab-1">el: '#main-region',</div>
                <br>
                <div class="tab-1">template: mainTemplate,</div>
                <br>
                <div class="tab-1">model: new MainContent(),</div>
                <br>
                <div class="tab-1">
                    <div class="comment">
                        /* Backbone Radio lets different modules communicate
                        through a global object, the channel. */
                    </div>
                </div>
                <div class="tab-1">
                    <strong>channel: Radio.channel('app'),</strong>
                </div>
                <br>
                <div class="tab-1">initialize: function() {</div>
                    <div class="tab-2">
                        var that = this;
                    </div>
                    <br>
                    <div class="tab-2">
                        <strong>this.channel.on('navigate', function(page) {</strong>
                    </div>
                        <div class="tab-3">
                            <div class="comment">
                                /* When a navigate event is triggered from the
                                AppController, set the activeContent attribute
                                on the model. Navigation occurs before the
                                content is retrieved, so the value is stored
                                to be looked up after the fetch finishes. */
                            </div>
                        </div>
                        <div class="tab-3">
                            <strong>that.model.setActiveContent(page);</strong>
                        </div>
                        <div class="tab-3">
                            <div class="comment">
                                /* Render the view if content has been fetched. */
                            </div>
                        </div>
                        <div class="tab-3">
                            <strong>if (that.model.get('content')) {</strong>
                        </div>
                            <div class="tab-4">
                                <strong>that.render();</strong>
                            </div>
                        <div class="tab-3">
                            <strong>}</strong>
                        </div>
                    <div class="tab-2">
                        <strong>});</strong>
                    </div>
                    <br>
                    <div class="tab-2">this.model.fetch()</div>
                        <div class="tab-3">.fail(function() {</div>
                            <div class="tab-4">that.model.setActiveContent('error');</div>
                        <div class="tab-3">})</div>
                        <div class="tab-3">.always(function() {</div>
                            <div class="tab-4">that.render();</div>
                        <div class="tab-3">});</div>
                <div class="tab-1">}</div>
            });
        </code>
    </div>
    <p>
        And that's it! Run the Browserify command to see the the content change when you click the links. Continue exploring the Backbone, Marionette, and Materialize documentation to customize and add functionality to your application.
    </p>
</div>
